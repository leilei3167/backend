
# 语言篇

[数据库篇](db.md)  

[通用技术篇](common.md)

[中间件篇](mid.md)

- [语言篇](#语言篇)
  - [参考](#参考)
    - [1.Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？](#1golang中除了加mutex锁以外还有哪些方式安全读写共享变量)
    - [2.无缓冲 Chan 的发送和接收是否同步?](#2无缓冲-chan-的发送和接收是否同步)
    - [3.GMP调度模型,尽可能的详细](#3gmp调度模型尽可能的详细)
    - [4.JSON 标准库对 nil slice 和 空 slice 的处理是一致的吗？](#4json-标准库对-nil-slice-和-空-slice-的处理是一致的吗)
    - [5.协程，线程，进程的区别](#5协程线程进程的区别)
    - [6.互斥锁，读写锁，死锁问题,怎么解决](#6互斥锁读写锁死锁问题怎么解决)
    - [7.三色标记法](#7三色标记法)
    - [8.什么是data race? data Race问题怎么解决？能不能不加锁解决这个问题？](#8什么是data-race-data-race问题怎么解决能不能不加锁解决这个问题)
    - [9.什么是channel，为什么它可以做到线程安全？](#9什么是channel为什么它可以做到线程安全)
    - [10.怎么查看Goroutine的数量?](#10怎么查看goroutine的数量)
    - [11. map是并发安全的吗？怎么解决并发安全问题？](#11-map是并发安全的吗怎么解决并发安全问题)
    - [12.go struct能不能比较](#12go-struct能不能比较)
    - [13.主协程如何等其余协程完再操作?](#13主协程如何等其余协程完再操作)
    - [14.切片的实现?](#14切片的实现)
    - [15.map如何顺序读取?](#15map如何顺序读取)
    - [16.什么是结构体tag，怎么用?](#16什么是结构体tag怎么用)
    - [17.slice深拷贝和浅拷贝](#17slice深拷贝和浅拷贝)
    - [18.map触发扩容的时机，满足什么条件时扩容？](#18map触发扩容的时机满足什么条件时扩容)
    - [19.make和new什么区别?](#19make和new什么区别)
    - [20.pprof怎么使用？什么是火焰图?](#20pprof怎么使用什么是火焰图)
    - [21.数组与切片的区别?](#21数组与切片的区别)
    - [22.beego和gin的区别?为什么gin比beego要快?](#22beego和gin的区别为什么gin比beego要快)
    - [23.defer的原理](#23defer的原理)
      - [defer扩展](#defer扩展)
    - [24.什么是cas？Go中CAS是怎么回事？](#24什么是casgo中cas是怎么回事)
    - [25.Go值接收者和指针接收者的区别？](#25go值接收者和指针接收者的区别)
    - [26.Goroutine发生了泄漏如何检测？](#26goroutine发生了泄漏如何检测)
    - [27.为何GPM调度要有P?](#27为何gpm调度要有p)
    - [28.什么是闭包？什么是闭包的延迟加载?](#28什么是闭包什么是闭包的延迟加载)
    - [29.如何限制goroutine的数量?控制在多少个比较合适?](#29如何限制goroutine的数量控制在多少个比较合适)
    - [30.互斥锁有几种模式?](#30互斥锁有几种模式)
    - [31.go中的逃逸分析是什么?](#31go中的逃逸分析是什么)
    - [32.sync.Pool用过吗?是怎么用的?](#32syncpool用过吗是怎么用的)

## 参考

[Go设计与实现](https://draveness.me/golang/)

[Go修养之路](https://www.topgoer.cn/docs/golangxiuyang/golangxiuyang-1cmedc59gtgpi)

### 1.Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？

Golang中Goroutine 可以通过 Channel 进行安全读写共享变量,还可以进行原子性操作

### 2.无缓冲 Chan 的发送和接收是否同步?

`ch := make(chan int)`无缓冲的channel由于没有缓冲发送和接收需要同步.  

`ch := make(chan int, 2)`有缓冲channel不要求发送和接收操作同步.

channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据。
channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。

### 3.GMP调度模型,尽可能的详细

<https://github.com/lifei6671/interview-go/blob/master/base/go-gpm.md>  

CSP用于描述两个独立的并发实体通过共享的通讯channel进行通讯的并发模型
在GO中并发实体就是goroutine,他是一种运行在用户态的轻量级线程,由go的调度器进行调度;channel在go中是
被单独创建的,功能就是实现协程间的通信

G代表的就是goroutine,M代表的是内核线程,P代表的是GM运行所需要的资源,p的数量可以通过GOMAXPROCS来进行设置,
每个P会有自己的本地队列(256个),当M要执行G时,必须通过与之绑定的P取出本地队列的G,G不够时会从全局队列获取,或者
从其他P中偷取

当M执行的G进行了系统调用会怎么办?
    此刻M会跟着进入系统调用的状态,此时的P会和当前的M解绑,转而去找其他空闲的M来执行其余的G

### 4.JSON 标准库对 nil slice 和 空 slice 的处理是一致的吗？

不一致;
如果对一个未初始化的nil切片操作会报数组越界的错误,但nil切片可用于需要返回切片的函数,在函数异常时返回nil;
空切片代表切片不为nil,只是里面没有值(指向的底层数组是空的),会告诉我们返回的是一个列表,只不过没有值;nil切片在json序列化后是NULL

### 5.协程，线程，进程的区别

<https://www.topgoer.cn/docs/golangxiuyang/golangxiuyang-1cmef1pfu03cf>

### 6.互斥锁，读写锁，死锁问题,怎么解决

什么是死锁?  

产生死锁的必要条件：

- 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
- 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
- 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

互斥锁:多个协程同时操作一个变量可能会出现错误,互斥锁可以使的在一个协程操作时,其他所有协程无法对其操作,保证
线程安全,但也造成一个问题,其他协程都在不断的进行激烈的锁竞争
读写锁:某些协程并不是都会对同一个变量执行写入操作,因此读写锁能够降低性能消耗(读写间互斥,多个读取直接不互斥,
多个写之间也互斥)

### 7.三色标记法

<https://zhuanlan.zhihu.com/p/105495961>

### 8.什么是data race? data Race问题怎么解决？能不能不加锁解决这个问题？

竞态,出现于多个goroutine修改同一变量时;
三方面解决:1.不要让多个协程同时具备改写同意变量的能力,可设置为一个协程修改,其余协程
向该协程传送数据;2,可以使用带缓冲1的channel实现互斥锁的功能;3,使用并发安全的写入方式,如原子操作以及sync.map

### 9.什么是channel，为什么它可以做到线程安全？

channel是go中的一个核心类型,可以把他看做是一个管道,先进先出的队列,在channel中,
发送一个数据和接收一个数据都是原子性的,用于在多个协程间通信,所以其本身就是线程安全的,channel底层用了互斥锁来保证并发安全

### 10.怎么查看Goroutine的数量?

`runtime`包中的`func NumGoroutine() int`,返回当前存在的协程数;`func GOMAXPROCS(n int) int`设置GMP调度中的P的数量

### 11. map是并发安全的吗？怎么解决并发安全问题？

map不是并发安全的;  
解决方法:1.加锁;2.使用channel(带缓冲1的channel可实现
与互斥锁相同的效果);3.使用sync.map

### 12.go struct能不能比较

> 能否比较:是否可以使用==或!=进行比较

结论:struct可以比较,**前提是他所有的字段都有可比性**,如果他们对应的非空字段相等,则两个结构体相等  

拓展:  

- slice,map,function这些是不能比较的,但也有特殊情况:他们都是nil时可以和nil进行比较,其余类型均是可以比较的  

- 同种类型的map可以比较;chan指向同一个通道即为true(两个chan被同一个make创建),也可以和nil比较
- **接口可以比较,动态类型和动态值均相等 则两个接口相等**  

总结:值类型可比较(要求他们装的字段也可以比较),接口类型可以比较(动态值和动态类型要相同),引用类型不能比较(仅仅只能和nil比较)

### 13.主协程如何等其余协程完再操作?

1.使用无缓冲channel,利用无缓冲channel读写阻塞的特性来实现同步
2.使用sync包中的WaitGroup,或者errorgroup

### 14.切片的实现?

[切片的原理](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/)  

### 15.map如何顺序读取?

可将map的key值取出放入一个切片中,排序后即可按顺序读取map的values;  
也可以在一开始就维护一个切片,在存入map时将key按加入切片,遍历map时按照切片中存的key来取value

### 16.什么是结构体tag，怎么用?

<https://zhuanlan.zhihu.com/p/258978922>  

每个struct成员后面的用单引号标示的内容，它的定义永远都是以key-value的形式出现的,
比如在在序列化时,序列化的包会读取tag内容，对json结果进行重命名输出,或是增加某些属性,
如json的omitempty等,又比如在使用GORM时,可通过加gorm标签实现某些功能(指定外键等,
指定列名等)

### 17.slice深拷贝和浅拷贝

<https://mp.weixin.qq.com/s/uSOBfOLN4j3_VQtxHtJEWQ>  

1. 深拷贝（Deep Copy）：
拷贝的是数据本身，创造一个样的新对象，新创建的对象与原对象不共享内存，**新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值。既然内存地址不同，释放内存地址时，可分别释放。**
值类型的数据，默认全部都是深复制，Array、Int、String、Struct、Float，Bool。

2. 浅拷贝（Shallow Copy）：
拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化。释放内存地址时，同时释放内存地址。
引用类型的数据，默认全部都是浅复制，Slice，Map。

使用**copy函数可以实现对slice的深拷贝**(copy之后原切片修改不会影响到现切片)

### 18.map触发扩容的时机，满足什么条件时扩容？

[map的原理](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/)  

map在go中底层是用拉链法实现的哈希表,发生哈希冲突时,用链表来解决;map底层是若干个结构为bmap的bucket组成
的数组,每个bucket就是一个链表;bmap就是我们所说的桶,bmap最多能存放8个键值对,超出的话将会链接到一个新的bucket
即溢出桶
map中有增量扩容和等量扩容两种
    map扩容的条件:
            - **当负载因子(键的数量/bucket的数量)>6.5的时候:**
                代表元素太多,桶太少,翻倍扩容,要注意翻倍扩容后,值不会立刻迁入到新桶
            - **当溢出桶的数量>2^15时:**
                代表元素不是特别多,但溢出桶太多,很多桶没装满,目的是开辟新桶,将老桶中的
        元素迁移过去,紧密排列,目的是节省空间,提高查找效率

  都是采取渐进式的扩容,不会立马将所有键值对迁移到新桶  

### 19.make和new什么区别?

make 函数：
    能够创建类型所需的内存空间，返回引用类型的本身。
具有使用范围的局限性，仅支持 channel、map、slice 三种类型。
具有独特的优势，make 函数会对三种类型的内部数据结构（长度、容量等）赋值。

new 函数：
    能够创建并分配类型所需的内存空间，返回指针引用（指向内存的指针）。
可被替代，能够通过字面值快速初始化。

### 20.pprof怎么使用？什么是火焰图?

<https://segmentfault.com/a/1190000040670962>

### 21.数组与切片的区别?

数组是定长的,是值类型,长度无法动态变化(初始化时就已经确定)
而切片是引用类型,是一个轻量级的数据结构,包含指向底层数组的指针,长度,容量,会在需要时发生扩容

### 22.beego和gin的区别?为什么gin比beego要快?

1.Beego支持完整的MVC, Gin不支持完整的MVC（需要开发者自己实现MVC）
2.Beego支持正则路由， Gin不支持正则路由
3.Beego支持Session， Gin不支持Session(需要安装另外的包)
4.gin更加轻量级,性能更强,在业务相对简单时可以使用gin,而beego则更加全面,功能齐全,但是相对来说也更加重量级
一些

### 23.defer的原理

<https://zhuanlan.zhihu.com/p/63354092>  

defer底层主要是两个函数:  
     `func deferproc(siz int32, fn *funcval)`和
     `func deferreturn(arg0 uintptr)`  

当程序执行时会先执行`deferproc`,会将defer的对象插入到**goroutine关联的defer链表头部(也是因此,defer只对当前g有效)**,之后执行defer时就是按照出栈的顺序了

注意**return实际不是原子操作**,而是分为了两步,赋值和返回,而defer恰好是在这两步之间执行的!

#### defer扩展

**defer、return、返回值三者的执行逻辑应该是：return最先执行，return负责将结果写入返回值中；接着defer开始执行一些收尾工作；最后函数携带当前返回值真正退出**。

- 匿名返回值:return会创建一个临时变量存放返回值,之后defer再对t的修改不会影响返回值(所以输出为5)
- 有名返回值(t):return将5赋值给t,之后defer是对同一个变量t修改,最终返回的是被defer修改后的t

此类题关键点在于关注返回值为具名返回值还是匿名返回值

### 24.什么是cas？Go中CAS是怎么回事？

CAS算法（Compare And Swap）,是原子操作的一种, CAS算法是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。
Go中的CAS操作是借用了CPU提供的原子性指令来实现。CAS操作修改共享变量时候不需要对共享变量加锁，而是通过类似乐观锁的方式进行检查，本质还是不断的占用CPU 资源换取加锁带来的开销（比如上下文切换开销）。  

`atomic.CompareAndSwapInt32`具有三个参数，第一个是变量的地址，第二个是变量当前值，第三个是要修改变量为多少，该函数如果发现传递的old值等于当前变量的值，则使用第三个变量替换变量的值并返回true，否则返回false。
该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。

### 25.Go值接收者和指针接收者的区别？

两个方面来对比,从是否修改调用者来对比:

如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。
使用指针作为方法的接收者的理由：
方法能够修改接收者指向的值。
避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。

从实现接口方面来对比:
如果某个接口包含一个指针接收者的方法,那么只有调用此方法者为对应指针,才能实现这个接口(即将其赋值给接口)

### 26.Goroutine发生了泄漏如何检测？

可以通过Go自带的工具pprof检测诊断当前在系统上运行的Go进程的占用的资源.

### 27.为何GPM调度要有P?

<https://segmentfault.com/a/1190000040092613>  

最开始的go中只有G和M,M想要执行,放回G都必须访问全局队列,并且多线程访问同一资源需要加锁,主要有以下缺点:
1.激烈的全局锁竞争
2.如果一个G在执行中又创建G,此刻的M必须将G交给另一个M来执行,CPU在M件频繁切换增加系统开销
为了解决这个问题,引入了P
    每个 P 有自己的本地队列，大幅度的减轻了对全局队列的直接依赖，所带来的效果就是锁竞争的减少。而 GM 模型的性能开销大头就是锁竞争。
    每个 P 相对的平衡上，在 GMP 模型中也实现了 Work Stealing 算法，如果 P 的本地队列为空，则会从全局队列或其他 P 的本地队列中窃取可运行的 G 来运行，减少空转，提高了资源利用率。

### 28.什么是闭包？什么是闭包的延迟加载?

<https://www.bilibili.com/video/BV1hv411x7we?p=7>

闭包(Closure)通俗点讲就是能够访问外部函数内部变量的函数。像这样能被访问的变量通常被称为捕获变量。  

### 29.如何限制goroutine的数量?控制在多少个比较合适?

<https://segmentfault.com/a/1190000039773754>  

可以设置有缓冲的channel,每个协程开启时时向channel中写入一个数据,利用有缓冲通道缓冲满时会阻塞的原理限制goroutine的数量

### 30.互斥锁有几种模式?

Go实现的互斥锁有两种模式，分别是正常模式和饥饿模式。
在正常模式下，waiter按照先进先出（FIFO）的方式获取锁，但是一个刚被唤醒的waiter与新到达的goroutine竞争锁时，大概率是干不过的。新来的goroutine有一个优势：它已经在CPU上运行，并且有可能不止一个新来的，因此waiter极有可能失败。在这种情况下，waiter还需要在等待队列中排队。为了避免waiter长时间抢不到锁，当waiter超过 1ms 没有获取到锁，它就会将当前互斥锁切换到饥饿模式，防止等待队列中的waiter被饿死。

在饥饿模式下，锁的所有权直接从解锁（unlocking）的goroutine转移到等待队列中的队头waiter。新来的goroutine不会尝试去获取锁，也不会自旋。它们将在等待队列的队尾排队。
如果某waiter获取到了锁，并且满足以下两个条件之一，它就会将锁从饥饿模式切换回正常模式。
它是等待队列的最后一个goroutine
它等待获取锁的时间小于1ms
饥饿模式是在 Go 1.9版本引入的，它防止了队列尾部waiter一直无法获取锁的问题。与饥饿模式相比，正常模式下的互斥锁性能更好。因为相较于将锁的所有权明确赋予给唤醒的waiter，直接竞争锁能降低整体goroutine获取锁的延时开销。

### 31.go中的逃逸分析是什么?

<https://zhuanlan.zhihu.com/p/343562181>  

编译器通过逃逸分析技术去选择堆或者栈，逃逸分析的基本思想如下：检查变量的生命周期是否是完全可知的，如果通过检查，则可以在栈上分配。否则，就是所谓的逃逸，必须在堆上进行分配.  

发生逃逸的几种情况:  

    1. 变量类型不确定
    2. 暴露给外部指针(变量在函数外部存在引用,如函数内部创建的变量返回值为该变量的指针)
    3. 变量所占内存巨大

Go语言虽然没有明确说明逃逸分析规则，但是有以下几点准则，是可以参考的:  

- 逃逸分析是在编译器完成的，这是不同于jvm的运行时逃逸分析;
- 如果变量在函数外部没有引用，则优先放到栈中；
- 如果变量在函数外部存在引用，则必定放在堆中；

### 32.sync.Pool用过吗?是怎么用的?

Pool用来保存和复用临时对象,减少内存分配,降低GC压力;
典型场景就是在web程序中,对某个结构体的序列化和反序列化,当并发度较高时,会创建非常多的临时对象,而这些对象都是分配在堆上的,对GC会造成较大压力,影响程序性能
创建对象池之后在其中添加New函数,之后调用Get方法就能从Pool中获取到实例,用完之后Put放回对象池
