# 数据库

- [数据库](#数据库)
  - [MySQL](#mysql)
    - [1.MySQL事务的特性,或者说基本要素?](#1mysql事务的特性或者说基本要素)
    - [2.MySQL的事务的隔离级别?](#2mysql的事务的隔离级别)
    - [3.什么是脏读,幻读,不可重复读?](#3什么是脏读幻读不可重复读)
    - [4.什么是MVCC?实现原理是什么?](#4什么是mvcc实现原理是什么)
    - [5.MySQL的高可用方案有哪些?](#5mysql的高可用方案有哪些)
    - [6.utf8和utf8mb4有什么区别?](#6utf8和utf8mb4有什么区别)
    - [7.MySQL中乐观锁和悲观锁的区别?](#7mysql中乐观锁和悲观锁的区别)
    - [8.MySQL的索引主要有哪些?](#8mysql的索引主要有哪些)
    - [9.MySQL联合索引的最左匹配原则?](#9mysql联合索引的最左匹配原则)
    - [10.什么是聚簇索引和非聚簇索引?](#10什么是聚簇索引和非聚簇索引)
    - [11.如何查询一个字段是否命中了索引?](#11如何查询一个字段是否命中了索引)
    - [12.什么情况下不会命中索引?](#12什么情况下不会命中索引)
    - [13.MySQL的索引优化?](#13mysql的索引优化)
    - [14.为什么用了索引能够加快查询?](#14为什么用了索引能够加快查询)
    - [15.mysql数据如何恢复到任意时间点?](#15mysql数据如何恢复到任意时间点)
    - [16.为什么使用B+树来作为索引的存储结构?而不是B树?或者平衡二叉树等?](#16为什么使用b树来作为索引的存储结构而不是b树或者平衡二叉树等)
    - [17.innoDB是表锁还是行锁?](#17innodb是表锁还是行锁)
  - [Redis](#redis)
    - [1.Redis的数据类型?以及他们的数据结构?](#1redis的数据类型以及他们的数据结构)
    - [2.Redis为什么快?](#2redis为什么快)
    - [3.什么是非阻塞,IO多路复用机制?](#3什么是非阻塞io多路复用机制)
    - [4.什么是缓存雪崩,缓存穿透,缓存击穿? 如何解决这些问题?](#4什么是缓存雪崩缓存穿透缓存击穿-如何解决这些问题)
    - [5.Redis有哪些持久化模式?原理是什么?](#5redis有哪些持久化模式原理是什么)
      - [5.1持久化原理](#51持久化原理)
    - [6.Redis的缓存淘汰原理?](#6redis的缓存淘汰原理)
      - [6.1什么是LRU算法?](#61什么是lru算法)
    - [7.Redis内存满了(达到最大内存设置)怎么办?](#7redis内存满了达到最大内存设置怎么办)
    - [8.Redis默认内存多少可以用?一般生产环境如何配置?](#8redis默认内存多少可以用一般生产环境如何配置)
    - [9.Redis的删除策略](#9redis的删除策略)
    - [10.主从复制原理?](#10主从复制原理)
    - [11.Redis有哪些高可用方案?你用的哪种?](#11redis有哪些高可用方案你用的哪种)
  - [MongoDB](#mongodb)
  - [ES](#es)

## MySQL

### 1.MySQL事务的特性,或者说基本要素?

ACID:

1. 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，**事务中的操作要么全部成功，要么全部失败**。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。 回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
2. 一致性（Consistency） **事务必须使数据库从一个一致性状态变换到另外一个一致性状态**。以转账为例子，A向B转账，假设转账之前这两个用户的钱加起来总共是100，那么A向B转账之后，不管这两个账户怎么转，A用户的钱和B用户的钱加起来的总额还是100，这个就是事务的一致性;不可能说在A转账时刚扣完款,服务器宕机了,导致B账户余额未增加,A被白白扣款
3. 隔离性（Isolation） 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，**同一时间，只允许一个事务请求同一数据,数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离**。 即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
4. 持久性（Durability） **一旦事务提交，则其所做的修改将会永远保存到数据库中**。即使系统发生崩溃，事务执行的结果也不能丢失。 可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。

上述的原子性,隔离性,持久性其实就是为了保证一致性

### 2.MySQL的事务的隔离级别?

1. 串行化 (Serializable) -- 相当于强行互斥,大幅度降低性能,基本不用 所有事务一个接着一个的执行，这样可以避免幻读 (phantom read)，对于基于锁来实现并发控制的数据库来说，串行化要求在执行范围查询的时候，需要获取范围锁，如果不是基于锁实现并发控制的数据库，则检查到有违反串行操作的事务时，需回滚该事务。
2. 可重复读 (Repeatable Read)(**MySQL默认隔离级别**) 所有被 Select 获取的数据都不能被修改，这样就可以避免一个事务前后读取数据不一致的情况。但是却没有办法控制幻读，因为这个时候其他事务不能更改所选的数据，但是可以增加数据，即前一个事务有读锁但是没有范围锁，为什么叫做可重复读等级呢？那是因为该等级解决了下面的不可重复读问题。 **注意：现在主流数据库都使用 MVCC 并发控制，使用之后RR（可重复读）隔离级别下是不会出现幻读的现象。**
3. 读已提交 (Read-Committed) 也叫提交读,该级别的事务能读取到已经提交的事务的数据,不会有脏读的问题;但被读取的数据也可以被其他事务修改，这样可能导致(**在不同时间的相同SQL查询中得到不同的结果,即不可重复读**(如一次事务中,首先执行了SQL_1,之后做了其他操作,之后再次执行SQL_1,两次SQL_1语句得到的结果不一样))。也就是说，事务读取的时候获取读锁，但是在读完之后立即释放(不需要等事务结束)，而写锁则是事务提交之后才释放，释放读锁之后，就可能被其他事务修改数据。
4. 读未提交 (Read-Uncommitted) 最低的隔离等级，一个事务可以读取到另一个未提交事务的数据，会导致脏读(因为其他事务未提交的数据可能是会回滚的,因此是脏数据)。 总结: 四个级别逐渐降低，每个级别解决一个问题，事务级别越高，性能越差，大多数环境(Read committed 就可以用了)

### 3.什么是脏读,幻读,不可重复读?

1. 脏读:**读取到其他事务未提交的数据**,由于该数据可能会发生回滚,因此这种数据被称为脏数据,这种读取到脏数据的行为被称之为脏读
2. 幻读:**幻读的重点在于新增或者删除**,同样的条件, 第1次和第2次读出来的记录数不一样(如`SELECT*` 得到某个表的总行数a,第二次执行`SELECT*` 发现总数行b,相比于a增加了若干行数据)
3. 不可重复读:**不可重复读的重点是修改**,同样的SQL语句条件，第1次和第2次读取的值不一样(因为读已提交,第一次执行的查询语句和第二次执行中间间隔时间,其他事务是可以修改数据的)

### 4.什么是MVCC?实现原理是什么?

即`MultiVersion Concurrency Control 多版本并发控制`:通过记录多个修改的历史版本来替代锁,属于乐观锁的一种实现,实现事务间的隔离效果,保证非阻塞读

MVCC的两种读形式:

- 快照读
读取的只是当前事务的可见版本，不用加锁。而你只要记住,**简单的select操作就是快照读**(select * from table where id = xxx)。
- 当前读
**读取的是当前版本，比如 特殊的读操作，更新/插入/删除操作.**

MVCC 使用了“三个隐藏字段”来实现版本并发控制，MySQL在创建建表的时候 innoDB 创建的几个隐藏列:`RowID(自定创建的id) DB_TRX_ID(事务的id) DB_ROLL_PTR(回滚指针) 以及一个删除标记字段`

- `RowID`：隐藏的自增ID，当建表没有指定主键，InnoDB会使用该RowID创建一个聚簇索引。
- `DB_TRX_ID`：**最近修改（更新/删除/插入）该记录的事务ID**。
- `DB_ROLL_PTR`：回滚指针，指向这条记录的上一个版本。
- 还有一个删除的flag字段,用来判断该记录是否已经删除

### 5.MySQL的高可用方案有哪些?

1. 主从或半主从复制
一主一从双节点,原理：主库将变更写binlog日志，然后从库连接到主库后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中，接着从库中有一个sql线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再执行一遍sql，这样就可以保证自己跟主库的数据一致。中小型规模此种形式最省事;一般需要搭配`keepalived`来使用
问题:这里有很重要一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行操作，在从库上会串行化执行，由于从库从主库拷贝日志以及串行化执行sql特点，在高并发情况下，从库数据一定比主库慢一点，是有延时的，所以经常出现，刚写入主库的数据可能读不到了，要过几十毫秒，甚至几百毫秒才能读取到。还有一个问题，如果突然主库宕机了，然后恰巧数据还没有同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。所以mysql实际上有两个机制，一个是**半同步复制**，用来解决主库数据丢失问题，一个是**并行复制**，用来解决主从同步延时问题。

      - 半同步复制：semi-sync复制，指的就是主库写入binlog日志后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，**主库接收到至少一个从库ack之后才会认为写完成**。
      - 并发复制：指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这样库级别的并行。（将主库分库也可缓解延迟问题）

2. MMM/MHA高可用方案
MMM提供了MySQL主主复制配置的监控、故障转移和管理的一套可伸缩的脚本套件。在MMM高可用方案中，典型的应用是双主多从架构，通过MySQL replication技术可以实现两个服务器互为主从，且在任何时候只有一个节点可以被写入，避免了多点写入的数据冲突。
同时，当可写的主节点故障时，MMM套件可以立刻监控到，然后将服务自动切换到另一个主节点，继续提供服务，从而实现MySQL的高可用。

3. Heartbeat/SAN高可用方案
在这个方案中，处理failover的方式是高可用集群软件Heartbeat，它监控和管理各个节点间连接的网络，并监控集群服务，当节点出现故障或者服务不可用时，自动在其他节点启动集群服务。
在数据共享方面，通过SAN（Storage Area Network）存储来共享数据，这种方案可以实现99.990%的SLA。

4. Heartbeat/DRBD高可用方案
这个方案处理failover的方式上依旧采用Heartbeat，不同的是，在数据共享方面，采用了基于块级别的数据同步软件DRBD来实现。
DRBD是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。和SAN网络不同，它并不共享存储，而是通过服务器之间的网络复制数据。

5. NDB CLUSTER高可用方案
国内用NDB集群的公司非常少，貌似有些银行有用。NDB集群不需要依赖第三方组件，全部都使用官方组件，能保证数据的一致性，某个数据节点挂掉，其他数据节点依然可以提供服务，管理节点需要做冗余以防挂掉。
缺点是：管理和配置都很复杂，而且某些SQL语句例如join语句需要避免。

### 6.utf8和utf8mb4有什么区别?

Mysql支持的 utf8 编码最大字符长度为3字节(utf8mb3)，如果遇到 4 字节的宽字符就会插入异常了,utf8mb4的编码，mb4就是`most bytes 4`的意思，专门用来兼容四字节的unicode

### 7.MySQL中乐观锁和悲观锁的区别?

- 悲观锁(Pessimistic Lock)
悲观锁顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁,典型的就是互斥锁。

传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

- 乐观锁(Optimistic Lock),
乐观锁顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。

乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。

乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。

乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，同时需要一个重试的机制

在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前获取的相同，并更新版本号，即可确认这之间没有发生并发的修改。如果更新失败即可认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，需要回滚整个业务操作并可根据需要重试整个过程。除了版本号实现也可以CAS实现

- 像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。

但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。

### 8.MySQL的索引主要有哪些?

>“索引（在MySQL中也叫“键key”）是存储引擎快速找到记录的一种数据结构。”

- UNIQUE(唯一索引)：不可以出现相同的值，可以有NULL值;可以通过`ALTER TABLE table_name ADD UNIQUE (column);`创建唯一索引
- INDEX(普通索引)：允许出现相同的索引内容,基本没啥限制;通过`ALTER TABLE table_name ADD INDEX index_name (column);`创建
- PROMARY KEY(主键索引)：它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。注意：一个表只能有一个主键。
- fulltext index(全文索引)：也称全文检索，是目前搜索引擎使用的一种关键技术;可以通过`ALTER TABLE table_name ADD FULLTEXT (column);`创建全文索引
- 组合索引：即一个索引包含多个列，多用于避免回表查询;通过`ALTER TABLE table_name ADD INDEX index_name(column1,column2, column3);`创建,可以创建唯一组合索引`ALTER TABLE table_name ADD UNIQUE (column1,column2)`

**索引一经创建不能修改，如果要修改索引，只能删除重建**。可以使用`DROP INDEX index_name ON table_name;`删除索引。

索引的设计原则:

- 适合索引的列是出现在WHERE子句中的列,或者连接子句中指定的列
- 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间
- 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可

索引相关的重要概念:

- 基数: 单个列唯一键（distict_keys）的数量叫做基数。如一个user表中,有性别(0,1)表示,假设user表有5条数据,性别列的基数就是2(唯一键数量只有2),说明性别有大量的重复值以此为索引查询将返回大量的数据,;查询语句返回表中大约30%内的数据会走索引，返回超过30%数据就使用全表扫描
- 回表: **当对一个列创建索引之后，索引会包含该列的键值及键值对应行所在的rowid。通过索引中记录的rowid访问表中的数据就叫回表**。回表次数太多会严重影响SQL性能，如果回表次数太多，就不应该走索引扫描，应该直接走全表扫描。

### 9.MySQL联合索引的最左匹配原则?

1. 在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先.
在检索数据时从联合索引的最左边开始匹配，**Mysql会一直向右匹配直到遇到范围查询（>、<、between、like）就停止匹配了**.  
就比如 a=3 and b=4 and c>5 and d=6如果建立(abcd)顺序的索引,d就用不到索引了，如果建立(abdc)的索引则都可以用到索引，其中abd的顺序可以任意调整，因为查询优化器会重新编排（即使是c>5 and b=4 and d=6 and a=3也会全部用到 abdc索引 ）.

2. `=`和in可以乱序，比如a=1 and b=2 and c=3 建立(abc)索引可以任意顺序，mysql查询优化器会优化顺序.
这里需要注意下, 比如abc索引 那么只要查询条件有a即可用到abc索引（如abc ab ac a）,没有a就用不到。

最左前缀匹配成因：**Mysql是创建复合索引的规则是根据索引最左边的字段进行排序**，在第一个字段排序的基础上再进行第二个字段排序，类似于order by col1，col2… 所以第一个字段是绝对有序的 第二个字段就是无序的了，所以Mysql 强调最左前缀匹配.

### 10.什么是聚簇索引和非聚簇索引?

- 聚簇索引：**将数据存储与索引放到了一块(叶子结点)，找到索引也就找到了数据**,找到了索引就找到了需要的数据，那么这个索引就是聚簇索引，所以主键就是聚簇索引，修改聚簇索引其实就是修改主键。
- 非聚簇索引：将数据存储于与索引分开的结构，**索引结构的叶子节点指向了数据的对应行**，索引的存储和数据的存储是分离的，也就是说找到了索引但没找到数据，**需要根据索引上的值(主键)再次回表查询**,非聚簇索引也叫做**辅助索引**;myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因

**InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。**

**`innodb`中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值。**

1. 对于聚簇索引表来说，表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。
**使用的是B+树作为索引的存储结构**，非叶子节点都是索引**关键字**，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。**叶子节点上的数据是主键与具体记录(数据内容)。**

2. 对于非聚簇索引表来说，表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，**叶子节点存储的是索引+索引对应的记录的数据**。

`聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针`

### 11.如何查询一个字段是否命中了索引?

使用 `explain`命令,格式为 `explain <SQL语句>`,`explain`命令用于查看这个SQL语句的**执行计划**,查看该SQL语句有没有使用上了索引，有没有做全表扫描

### 12.什么情况下不会命中索引?

通常不命中索引有几种情况:

- 索引规范不合理,sql解析器不命中索引.
- 表中索引是以表中数据量字段最多的建立的索引,sql解析器不命中索引.(实际就是索引没用,最后全局查找了)
- bool的字段做索引,sql选择器不命中索引.
- 模糊查询 %like
- 索引列参与计算,使用了函数
- 非最左前缀顺序
- where对null判断
- where不等于`!=`
- or操作有至少一个字段没有索引
- 需要回表的查询结果集过大（超过配置的范围）

### 13.MySQL的索引优化?

- 前导模糊查询不能使用索引(如 `%aaa`)。
- union、in、or 都能够命中索引，建议使用 in。
- 负向条件查询不能使用索引，可以优化为 in 查询。
- 联合索引最左前缀原则（又叫最左侧查询）
- 范围列可以用到索引（联合索引必须是最左前缀）。
- 计算放到业务层而不是数据库层。
- 不允许会全表扫描强制类型转换
- 更新十分频繁、数据区分度不高的字段上不宜建立索引。
- 如果有 order by、group by 的场景，请注意利用索引的有序性。
- 利用覆盖索引来进行查询操作，避免回表。
- 建立索引的列，不允许为 null。
- 超过三个表最好不要 join。
- 单表索引建议控制在5个以内。
- 单索引字段数不允许超过5个。

### 14.为什么用了索引能够加快查询?

在数据十分庞大的时候，索引可以大大加快查询的速度，这是**因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。**

### 15.mysql数据如何恢复到任意时间点?

恢复到任意时间点**以定时的做全量备份，以及备份增量的 binlog 日志为前提**。恢复到任意时间点首先将全量备份恢复之后，再此基础上回放增加的 binlog 直至指定的时间点。

### 16.为什么使用B+树来作为索引的存储结构?而不是B树?或者平衡二叉树等?

<https://www.jianshu.com/p/79a14f59da13>

表数据都是存在磁盘中的,当从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读,并且从磁盘中读取速度比从内存中读取慢非常多,为了增大效率就要尽可能减少磁盘读取次数,增大每次读取的数据量;**如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。**,对于这种需求,二叉树一个节点只存一个数据,那么树就会非常高,磁盘IO次数会非常多  
因此应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的B树(Balance Tree)。

**B树每个节点称为页，页就是我们上面说的磁盘块，在mysql中数据读取的基本单位都是页**，所以我们这里叫做页更符合mysql中索引的底层数据结构。B树相对于平衡二叉树，每个节点存储了更多的键值(key)和数据(data)，并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的B树为3阶B树，高度也会很低。 基于这个特性，B树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。

而B+树是对B树的进一步优化:

1. **B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。**之所以这么做是因为在数据库中页的大小是固定的，innodb中**页的默认大小是16KB**。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。另外，B+树的阶数是等于键值的数量的，如果我们的B+树一个节点可以存储1000个键值，那么3层B+树可以存储1000×1000×1000=10亿个数据。一般根节点是常驻内存的，所以一般我们查找10亿数据，只需要2次磁盘IO。
2. **因为B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。**
3. **B+树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的**。

### 17.innoDB是表锁还是行锁?

可以支持行锁,但行锁是基于索引的,**没有命中索引会退化为表锁**

## Redis

### 1.Redis的数据类型?以及他们的数据结构?

1. String:字符串,最基本的类型,其他几种数据结构都是在字符串基础之上构建的,常用于缓存,计数,Session,存验证码,短信验证码等
2. List:列表,由**双向链表**实现,是有序的,value可以重复,可以通过下标取元素,可以做简单的消息队列,可用于程序数据上报的临时缓存,便于被数据收集组件批量收集,增大吞吐量
3. Hash:**指键值本身又是一个键值对结构**,可以用来存放用户信息,如购物车等(key:用户ID,Value:{商品1:XXX,商品2:xxx}),相当于go中的`map[string]map[string]string`,可用于存储结构化的数据,如一个userID的所有字段信息
4. Set:集合,也是用来**一个Key对应保存多个的字符串元素**，但和列表类型不一 样的是，集合中**不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素**。**利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。**
5. Zset:有序集合,在集合基础上多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。

### 2.Redis为什么快?

- 纯内存操作

- 单线程操作，避免了频繁的上下文切换

- 合理高效的数据结构

- 采用了非阻塞I/O多路复用机制

### 3.什么是非阻塞,IO多路复用机制?

<https://blog.csdn.net/weixin_43673156/article/details/124101608>

### 4.什么是缓存雪崩,缓存穿透,缓存击穿? 如何解决这些问题?

<https://zhuanlan.zhihu.com/p/346651831>

1. 缓存雪崩:
当某一个时刻出现**大规模的缓存失效的情况**，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。
    - 分析:成因在于同一时间大规模的key失效,可能是**Redis宕机,另一种可能是key采用了相同的过期时间**
    - 解决方案:1.原有过期时间上加上一个随机值(1-5分钟随机),避免同一时间大量缓存同时失效;2.限流熔断措施,达到阈值时返回忙,避免过的请求打数据库;3.提高数据库,redis可用性

2. 缓存穿透
我们使用Redis大部分情况都是通过Key查询对应的值，假如**发送的请求传进来的key是不存在Redis中的，那么就查不到缓存，查不到缓存就会去数据库查询**。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。
    - 解决方案:1.设置布隆过滤器,布隆过滤器的作用是某个 key 不存在，那么就一定不存在，它说某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询 key 是否存在，如果不存在就直接返回;2.将不存在的key也缓存(值为null)

3. 缓存击穿
其实跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而**缓存击穿是一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了**，导致大并发全部打在数据库上，导致数据库压力剧增

      - 解决方案:设置热点KEY永不过期

### 5.Redis有哪些持久化模式?原理是什么?

有两种方式:

- RDB(默认方式): RDB方式是通过快照（ snapshotting ）完成的。它保存的是某一时刻的数据并**不关注过程**。RDB保存redis某一时刻的数据的快照
- AOF(默认没有开启): Redis 将所有对数据库进行过写入的命令（及其参数）（RESP）记录到 AOF 文件， 以此达到记录数据库状态的目的，这样当Redis重启后只要按顺序回放这些命令就会恢复到原始状态了。AOF会记录过程，RDB只管结果,AOF有3种模式
  - always: 每一个写命令都立即同步到aof,最安全,但最慢
  - everysec(默认): 每秒同步一次
  - no: redis不交给OS处理,最不安全
一般都是`everysec`,兼顾速度与安全

#### 5.1持久化原理

>Redis内部的定时任务机制，定时任务执行的频率可以在配置文件中通过 hz 10 来设置（这个配置表示1s内执行10次，也就是每100ms触发一次定时任务）。该值最大能够设置为：500，但是不建议超过：100，因为值越大说明执行频率越频繁越高，这会带来CPU的更多消耗，从而影响主进程读写性能。

在恢复数据时,Redis会先检查AOF文件是否存在,如果不存在才会尝试加载RDB,因为AOF保存的数据更加完整

1. RDB的原理
<https://zhuanlan.zhihu.com/p/345725544>
redis 在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。
对于 RDB 方式，redis 会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何 IO 操作的，这样就确保了 redis 极高的性能。
如果需要进行大规模数据的恢复，且对**于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效**。
2. AOF的原理
我们通过配置 redis.conf 中的 appendonly yes 就可以打开 AOF 功能。如果有写操作（如 SET 等），redis 就会被追加到 AOF 文件的末尾。

默认的 AOF 持久化策略是每秒钟 fsync 一次（fsync 是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis 仍然可以保持很好的处理性能，即使 redis 故障，也只会丢失最近 1 秒钟的数据。

如果在追加日志时，恰好遇到磁盘空间满、inode 满或断电等情况导致日志写入不完整，也没有关系，redis 提供了 **redis-check-aof** 工具，可以用来进行日志修复。

因为采用了追加方式，**如果不做任何处理的话，AOF 文件会变得越来越大**，为此，redis 提供了 AOF 文件重写（rewrite）机制，即当 AOF 文件的大小超过所设定的阈值时，redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集。举个例子或许更形象，假如我们调用了 100 次 INCR 指令，在 AOF 文件中就要存储 100 条指令，但这明显是很低效的，完全可以把这 100 条指令合并成一条 SET 指令，这就是重写机制的原理。

在进行 AOF 重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响 AOF 文件的可用性

### 6.Redis的缓存淘汰原理?

<https://zhuanlan.zhihu.com/p/142893249>

1、**noevication** : 不会驱逐任何 key (默认),达到上限报错
2、**allkeys-lru**: 对所有的 key 使用 lru 算法进行删除
3、volatile-lru: 对所有的设置了过期时间的 key 进行 lru 算法进行删除
4、**allkeys-random**: 对所有 key 随机删除
5、volatile-random: 对所有设置了过期时间的 key 随机删除
6、volatile-ttl ：马上删除要过期的 key
7、**allkeys-lfu**: 对所有 key 进行 lfu 算法进行删除
8、volatile-lfu: 对所有设置了过期时间的 key 使用 lfu 算法进行删除

实际工作中用`allkeys-lru`

#### 6.1什么是LRU算法?

>LRU(Least Recently Used)即表示最近最少使用，也就是在**最近的时间内最少被访问的key，算法根据数据的历史访问记录来进行淘汰数据**。它的核心的思想就是：假如一个key值在最近很少被使用到，那么在将来也很少会被访问。

实际上Redis实现的LRU并不是真正的LRU算法，也就是名义上我们使用LRU算法淘汰键，但是实际上被淘汰的键并不一定是真正的最久没用的。

>Redis使用的是近似的LRU算法，通过**随机采集法淘汰key，每次都会随机选出5个key，然后淘汰里面最近最少使用的key**。

LRU的缺点就是会误判一个Key的热度情况,比如一个key以前经常被访问,只是最近没被访问,那么就会被当做冷数据淘汰;反之,一个冷门数据只是最近恰好被访问,就会被当做热点数据,不容易被淘汰

5个是默认的个数,可以修改,取值越大会越接近真实的LRU算法

为了弥补LRU的缺点,后来引入了`allkeys-lfu`即LFU算法

>LFU(Least Frequently Used)即表示最近频繁被使用，也就是最近的时间段内，频繁被访问的key，它以最近的时间段的被访问次数的频率作为一种判断标准。它的核心思想就是：**根据key最近被访问的频率进行淘汰，比较少被访问的key优先淘汰，反之则优先保留。**

LFU算法反映了一个key的热度情况，不会因为LRU算法的偶尔一次被访问被认为是热点数据。

### 7.Redis内存满了(达到最大内存设置)怎么办?

Redis有6中内存淘汰策略,默认的是`noeviction`策略,在内存达到最大设置的值时,会报错`“(error) OOM command not allowed when used memory > 'maxmemory'.”`

### 8.Redis默认内存多少可以用?一般生产环境如何配置?

64位操作系统不限制,32位操作系统限制3GB,一般配置为物理内存的3/4

### 9.Redis的删除策略

>删除策略是对expires的维护。

在Redis种有三种删除的操作此策略，分别是：

1. 定时删除：创建一个定时器，定时的执行对key的删除操作。当前时间和expires中对过期时间一致时，定时器触发删除。
2. 惰性删除：数据到达过期时间，不做处理,每次只有再访问key的时候，才会检查key的过期时间，若是已经过期了就执行删除。
3. **定期删除**：每隔一段时间，就会检查删除掉过期的key。
定时删除对于内存来说是友好的，定时清理出干净的空间，但是对于cpu来说并不是友好的，程序需要维护一个定时器，这就会占用cpu资源。

惰性的删除对于cpu来说是友好的，cpu不需要维护其它额外的操作，但是对于内存来说是不友好的，因为要是有些key一直没有被访问到，就会一直占用着内存。

定期删除是上面两种方案的折中方案**每隔一段时间删除过期的key，也就是根据具体的业务，合理的取一个时间定期的删除key**。

通过最合理控制删除的时间间隔来删除key，减少对cpu的资源的占用消耗，使删除操作合理化。

Redis采用的策略是`惰性删除+定期删除`

### 10.主从复制原理?

### 11.Redis有哪些高可用方案?你用的哪种?

## MongoDB

## ES
