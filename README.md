
# 语言篇

[数据库篇](db.md)  

[通用技术篇](common.md)

[中间件篇](mid.md)

- [语言篇](#语言篇)
  - [参考](#参考)
    - [LIST](#list)
    - [1.Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？](#1golang中除了加mutex锁以外还有哪些方式安全读写共享变量)
    - [2.无缓冲 Chan 的发送和接收是否同步?](#2无缓冲-chan-的发送和接收是否同步)
    - [3.GMP调度模型,尽可能的详细](#3gmp调度模型尽可能的详细)
      - [3.1 goroutine的状态流转](#31-goroutine的状态流转)
      - [3.2 抢占式调度的过程](#32-抢占式调度的过程)
      - [3.3 若干线程中其中一个发生OOM(Out Of Memory)会怎么样?如果是若干个goroutine呢?](#33-若干线程中其中一个发生oomout-of-memory会怎么样如果是若干个goroutine呢)
    - [4.JSON 标准库对 nil slice 和 空 slice 的处理是一致的吗？](#4json-标准库对-nil-slice-和-空-slice-的处理是一致的吗)
    - [5.协程，线程，进程的区别](#5协程线程进程的区别)
    - [6.互斥锁，读写锁，死锁问题,怎么解决](#6互斥锁读写锁死锁问题怎么解决)
    - [7.GC工作原理(三色标记法)](#7gc工作原理三色标记法)
      - [7.1 GC触发时机?](#71-gc触发时机)
    - [8.什么是data race? data Race问题怎么解决？能不能不加锁解决这个问题？](#8什么是data-race-data-race问题怎么解决能不能不加锁解决这个问题)
    - [9.什么是channel，为什么它可以做到线程安全？](#9什么是channel为什么它可以做到线程安全)
    - [10.怎么查看Goroutine的数量?](#10怎么查看goroutine的数量)
    - [11. map是并发安全的吗？怎么解决并发安全问题？](#11-map是并发安全的吗怎么解决并发安全问题)
    - [12.go struct能不能比较](#12go-struct能不能比较)
    - [13.主协程如何等其余协程完再操作?](#13主协程如何等其余协程完再操作)
    - [14.切片的实现,扩容原理?](#14切片的实现扩容原理)
    - [15.map如何顺序读取?](#15map如何顺序读取)
    - [16.什么是结构体tag，怎么用?](#16什么是结构体tag怎么用)
    - [17.slice深拷贝和浅拷贝](#17slice深拷贝和浅拷贝)
    - [18.map触发扩容的时机，满足什么条件时扩容？](#18map触发扩容的时机满足什么条件时扩容)
    - [19.make和new什么区别?](#19make和new什么区别)
    - [20.pprof怎么使用？什么是火焰图?](#20pprof怎么使用什么是火焰图)
    - [21.数组与切片的区别?](#21数组与切片的区别)
    - [22.beego和gin的区别?为什么gin比beego要快?](#22beego和gin的区别为什么gin比beego要快)
    - [23.defer的原理](#23defer的原理)
      - [defer扩展](#defer扩展)
    - [24.什么是cas？Go中CAS是怎么回事？](#24什么是casgo中cas是怎么回事)
    - [25.Go值接收者和指针接收者的区别？](#25go值接收者和指针接收者的区别)
    - [26.Goroutine发生了泄漏如何检测？](#26goroutine发生了泄漏如何检测)
    - [27.为何GPM调度要有P?](#27为何gpm调度要有p)
    - [28.什么是闭包？什么是闭包的延迟加载?](#28什么是闭包什么是闭包的延迟加载)
    - [29.如何限制goroutine的数量?控制在多少个比较合适?](#29如何限制goroutine的数量控制在多少个比较合适)
    - [30.互斥锁有几种模式?](#30互斥锁有几种模式)
    - [31.go中的逃逸分析是什么?](#31go中的逃逸分析是什么)
    - [32.sync.Pool用过吗?是怎么用的?](#32syncpool用过吗是怎么用的)
    - [33.init的执行顺序](#33init的执行顺序)
    - [34.接口的内部实现](#34接口的内部实现)
    - [35.Go的内存管理原理](#35go的内存管理原理)
      - [管理模型](#管理模型)
      - [逃逸分析](#逃逸分析)
      - [GC](#gc)
    - [36.什么是内存对齐?为什么要有内存对齐?](#36什么是内存对齐为什么要有内存对齐)
    - [37.defer的原理?](#37defer的原理)
    - [38.删除切片中间某个元素?](#38删除切片中间某个元素)
    - [39.使用一个字符串名称调用函数](#39使用一个字符串名称调用函数)
    - [string转为byte切片是否会发生内存分配?如何避免内存分配?](#string转为byte切片是否会发生内存分配如何避免内存分配)
    - [40.两个goroutin交替打印](#40两个goroutin交替打印)

## 参考

[Go设计与实现](https://draveness.me/golang/)

[Go修养之路](https://www.topgoer.cn/docs/golangxiuyang/golangxiuyang-1cmedc59gtgpi)

[面试题汇总1](https://www.topgoer.cn/docs/interview/interview-1dks8a8s7sevg)

[面试题汇总2](https://github.com/KeKe-Li/data-structures-questions/blob/master/src/chapter05/golang.01.md#G0%E7%9A%84%E4%BD%9C%E7%94%A8)

### LIST

- [ ] 内存管理3个角度分析
- [ ] map原理深入理解

### 1.Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？

Golang中Goroutine 可以通过 Channel 进行安全读写共享变量,还可以进行原子性操作

### 2.无缓冲 Chan 的发送和接收是否同步?

`ch := make(chan int)`无缓冲的channel由于没有缓冲发送和接收需要同步.  

`ch := make(chan int, 2)`有缓冲channel不要求发送和接收操作同步.

channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据。
channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。

### 3.GMP调度模型,尽可能的详细

<https://www.topgoer.cn/docs/golangxiuyang/golangxiuyang-1cmeduvk27bo0>
<https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/>

CSP用于描述两个独立的并发实体通过共享的通讯channel进行通讯的并发模型
在GO中并发实体就是goroutine,他是一种运行在用户态的轻量级线程,由go的调度器进行调度;channel在go中是
被单独创建的,功能就是实现协程间的通信

G代表的就是goroutine,M代表的是内核线程,P代表的是GM运行所需要的资源,p的数量可以通过GOMAXPROCS来进行设置,
每个P会有自己的本地队列(256个),当M要执行G时,必须通过与之绑定的P取出本地队列的G,G不够时会从全局队列获取,或者
从其他P中偷取

当M执行的G进行了系统调用会怎么办?
    此刻M会跟着进入系统调用的状态,此时的P会和当前的M解绑,转而去找其他空闲的M来执行其余的G

#### 3.1 goroutine的状态流转

<https://zhuanlan.zhihu.com/p/471490292>

- G的状态(8种)：

_Gidle：刚刚被分配并且还没有被初始化，值为0，为创建goroutine后的默认值

_Grunnable： 没有执行代码，没有栈的所有权，存储在运行队列中，可能在某个P的本地队列或全局队列中(如上图)。

_Grunning： 正在执行代码的goroutine，拥有栈的所有权(如上图)。

_Gsyscall：正在执行系统调用，拥有栈的所有权，与P脱离，但是与某个M绑定，会在调用结束后被分配到运行队列(如上图)。

_Gwaiting：被阻塞的goroutine，阻塞在某个channel的发送或者接收队列(如上图)。

_Gdead： 当前goroutine未被使用，没有执行代码，可能有分配的栈，分布在空闲列表gFree，可能是一个刚刚初始化的goroutine，也可能是执行了goexit退出的goroutine(如上图)。

_Gcopystac：栈正在被拷贝，没有执行代码，不在运行队列上，执行权在

_Gscan ： GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在。

- P的状态(5种)：

_Pidle ：处理器没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空

_Prunning ：被线程 M 持有，并且正在执行用户代码或者调度器(如上图)

_Psyscall：没有执行用户代码，当前线程陷入系统调用(如上图)

_Pgcstop ：被线程 M 持有，当前处理器由于垃圾回收被停止

_Pdead ：当前处理器已经不被使用

- M的状态：

自旋线程：处于运行状态但是没有可执行goroutine的线程，数量最多为GOMAXPROC，若是数量大于GOMAXPROC就会进入休眠。

非自旋线程：处于运行状态有可执行goroutine的线程。

#### 3.2 抢占式调度的过程

<https://www.cnblogs.com/luozhiyun/p/14589730.html>

GC时需要STW,也就是需要抢占所有的P,让他们停止工作,对于当前的P,系统调用的P,空闲的P直接设置为_gcstop即可,对于还有G在运行的P

在 Go 的 1.14 版本之前抢占试调度都是基于协作的，需要自己主动的让出执行，但是这样是无法处理一些无法被抢占的边缘情况。  
例如：for 循环或者垃圾回收长时间占用线程，这些问题中的一部分直到 1.14 才被**基于信号的抢占式调度**解决。

基于协作的抢占式调度的工作机制就是：

- **编译器会在调用函数前插入 runtime.morestack，可能会调用runtime.newstack进行抢占**
- Go 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms 时发出抢占请求 StackPreempt
- 当发生函数调用时，可能会执行编译器插入的 runtime.morestack，它调用的 runtime.newstack会检查 Goroutine 的 stackguard0 字段是否为 StackPreempt；
- 如果 stackguard0 是 StackPreempt，就会触发抢占让出当前线程；
但是这种调度并不完备，**比如一个goroutine运行了很久，但是它并没有调用另一个函数，则它不会被抢占**

基于信号的抢占式调度:  

在之前的依赖栈增长检测代码的方式，遇到没有函数调用的情况下就会出现问题，在Go1.14这一问题得到解决。
在Linux中这种真正的抢占式调度是基于信号完成的，所以也称为“异步抢占”

- **M 注册一个 `SIGURG` 信号的处理函数：sighandler。**

- `sysmon` 线程检测到执行时间过长的 goroutine 或者GC stw 时，会向相应的 M（或者说线程，每个线程对应一个 M）发送 `SIGURG` 信号。

- 收到信号后，内核执行 sighandler 函数，通过 pushCall 插入 asyncPreempt 函数调用。

- 回到当前 goroutine 执行 asyncPreempt 函数，通过 mcall 切到 g0 栈执行 gopreempt_m。

- 将当前 goroutine 插入到全局可运行队列，M 则继续寻找其他 goroutine 来运行。

- 被抢占的 goroutine 再次调度过来执行时，会继续原来的执行流。

#### 3.3 若干线程中其中一个发生OOM(Out Of Memory)会怎么样?如果是若干个goroutine呢?

如果线程发生OOM，也就是内存溢出，发生OOM的线程会被kill掉，其它线程不受影响。

### 4.JSON 标准库对 nil slice 和 空 slice 的处理是一致的吗？

不一致;
如果对一个未初始化的nil切片操作会报数组越界的错误,但nil切片可用于需要返回切片的函数,在函数异常时返回nil;
空切片代表切片不为nil,只是里面没有值(指向的底层数组是空的),会告诉我们返回的是一个列表,只不过没有值;nil切片在json序列化后是NULL

### 5.协程，线程，进程的区别

<https://www.topgoer.cn/docs/golangxiuyang/golangxiuyang-1cmef1pfu03cf>

### 6.互斥锁，读写锁，死锁问题,怎么解决

什么是死锁?  

产生死锁的必要条件：

- 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
- 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
- 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

互斥锁:多个协程同时操作一个变量可能会出现错误,互斥锁可以使的在一个协程操作时,其他所有协程无法对其操作,保证
线程安全,但也造成一个问题,其他协程都在不断的进行激烈的锁竞争
读写锁:某些协程并不是都会对同一个变量执行写入操作,因此读写锁能够降低性能消耗(读写间互斥,多个读取直接不互斥,
多个写之间也互斥)

### 7.GC工作原理(三色标记法)

<https://zhuanlan.zhihu.com/p/105495961>

>白色：不确定对象（默认色）；黑色：存活对象,无需进一步追踪。灰色：存活对象，基于该节点的追踪还未完成。
>没有灰色节点时,说明标记阶段可以结束了

基于root追踪对象的状态,追踪不到的一定是垃圾,需要清除

1. 先将所有对象加入白色集合（需要STW）
2. 然后将能直接追踪到的root节点对象标记为灰色(全局变量等),然后将一个对象从灰色集合取出，遍历其子对象，放入灰色集合。同时将取出的对象放入黑色集合，直到灰色集合为空,不存在灰色节点说明标记已完成
3. 最后的白色集合对象就是需要清理的对象。

为了提高GC效率,用户程序和GC是交替执行的,这也就带来了一个问题:

**如果GC刚标记一个对象的状态为黑色,切换到用户程序时该对象的引用又被用户修改了(如指向一个新的对象(会被标记为白色))，那么之前的标记就无效了,这个有效数据会被错误回收。因此Go采用了写屏障技术，当对象新增或者更新会将其着色为灰色。**

写屏障会在写操作中插入指令,目的是让GC知道对象已修改,因此写屏障要维护指令集

一次完整的GC分为五个阶段：

1. 需要STW,清扫终止阶段,准备下一个阶段并发标记,开启写屏障,用户程序对对象的修改才能经过写屏障的处理,保证强或弱三色不变性。
2. 开始标记
3. STW,周期内标记结束,关闭写屏障
4. 内存清扫阶段,需要将回收的内存归还到堆
5. 内存归还阶段,将过多的内存归还给操作系统

屏障技术:
>垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。

Go语言中结合使用的两种写屏障技术，分别是 Dijkstra 提出的**插入写屏障**和 Yuasa 提出的**删除写屏障**  

即(混合写屏障),**该写屏障会将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色**

基于插入写屏障和删除写屏障在结束时需要STW来重新扫描栈，带来性能瓶颈。混合写屏障分为以下四步：

1. GC开始时，将栈上的全部对象标记为黑色（不需要二次扫描，无需STW）；
2. GC期间，任何栈上创建的新对象均为黑色
3. 被删除引用的对象标记为灰色
4. 被添加引用的对象标记为灰色  

总而言之就是**确保黑色对象不能指向白色对象(强三色不变性)**，这个改进直接使得GC时间从 2s降低到2us。

#### 7.1 GC触发时机?

1. 主动调用`runtime.GC`
2. 被动触发
   - 超过2分钟没有产生GC时,强制触发
   - 使用步调（Pacing）算法，其核心思想是控制内存增长的比例(和堆增长率,CPU使用率有关)

### 8.什么是data race? data Race问题怎么解决？能不能不加锁解决这个问题？

竞态,出现于多个goroutine修改同一变量时;
三方面解决:1.不要让多个协程同时具备改写同意变量的能力,可设置为一个协程修改,其余协程
向该协程传送数据;2,可以使用带缓冲1的channel实现互斥锁的功能;3,使用并发安全的写入方式,如原子操作以及sync.map

### 9.什么是channel，为什么它可以做到线程安全？

channel是go中的一个核心类型,可以把他看做是一个管道,先进先出的队列,在channel中,
发送一个数据和接收一个数据都是原子性的,用于在多个协程间通信,所以其本身就是线程安全的,channel底层用了互斥锁来保证并发安全

### 10.怎么查看Goroutine的数量?

`runtime`包中的`func NumGoroutine() int`,返回当前存在的协程数;`func GOMAXPROCS(n int) int`设置GMP调度中的P的数量

### 11. map是并发安全的吗？怎么解决并发安全问题？

map不是并发安全的;  
解决方法:1.加锁;2.使用channel(带缓冲1的channel可实现
与互斥锁相同的效果);3.使用sync.map

### 12.go struct能不能比较

> 能否比较:是否可以使用==或!=进行比较

结论:struct可以比较,**前提是他所有的字段都有可比性**,如果他们对应的非空字段相等,则两个结构体相等  

拓展:  

- slice,map,function这些是不能比较的,但也有特殊情况:他们都是nil时可以和nil进行比较,其余类型均是可以比较的  

- 同种类型的map可以比较;chan指向同一个通道即为true(两个chan被同一个make创建),也可以和nil比较
- **接口可以比较,动态类型和动态值均相等 则两个接口相等**  

总结:值类型可比较(要求他们装的字段也可以比较),接口类型可以比较(动态值和动态类型要相同),引用类型不能比较(仅仅只能和nil比较)

### 13.主协程如何等其余协程完再操作?

1.使用无缓冲channel,利用无缓冲channel读写阻塞的特性来实现同步
2.使用sync包中的WaitGroup,或者errorgroup

### 14.切片的实现,扩容原理?

[切片的原理](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/)  

注意,切片的扩容策略在1.18版本中已经改变,旧版本:

- 如果期望容量大于当前容量的两倍就会使用期望容量；
- 如果当前切片的长度小于 1024 就会将容量翻倍；
- 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；

新版本:

- 如果期望容量大于当前容量的两倍就会使用期望容量；
- **如果当前切片容量小于256,则将容量翻倍**
- 大于256,按照公式扩容,直到大于等于所期望的容量(公式:`newcap += (newcap + 3*threshold) / 4`)

这个公式，对于容量小的切片，按照2倍的速率扩容和对于容量大的切片，按照1.25倍的速度扩容，为两者提供了平滑的过渡。

### 15.map如何顺序读取?

可将map的key值取出放入一个切片中,排序后即可按顺序读取map的values;  
也可以在一开始就维护一个切片,在存入map时将key按加入切片,遍历map时按照切片中存的key来取value

### 16.什么是结构体tag，怎么用?

<https://zhuanlan.zhihu.com/p/258978922>  

每个struct成员后面的用单引号标示的内容，它的定义永远都是以key-value的形式出现的,
比如在在序列化时,序列化的包会读取tag内容，对json结果进行重命名输出,或是增加某些属性,
如json的omitempty等,又比如在使用GORM时,可通过加gorm标签实现某些功能(指定外键等,
指定列名等)

### 17.slice深拷贝和浅拷贝

<https://mp.weixin.qq.com/s/uSOBfOLN4j3_VQtxHtJEWQ>  

1. 深拷贝（Deep Copy）：
拷贝的是数据本身，创造一个样的新对象，新创建的对象与原对象不共享内存，**新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值。既然内存地址不同，释放内存地址时，可分别释放。**
值类型的数据，默认全部都是深复制，Array、Int、String、Struct、Float，Bool。

2. 浅拷贝（Shallow Copy）：
拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化。释放内存地址时，同时释放内存地址。
引用类型的数据，默认全部都是浅复制，Slice，Map。

使用**copy函数可以实现对slice的深拷贝**(copy之后原切片修改不会影响到现切片)

### 18.map触发扩容的时机，满足什么条件时扩容？

[map的原理](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/)  

map在go中底层是用拉链法实现的哈希表,发生哈希冲突时,用链表来解决;map底层是若干个结构为bmap的bucket组成
的数组,每个bucket就是一个链表;bmap就是我们所说的桶,bmap最多能存放8个键值对,超出的话将会链接到一个新的bucket
即溢出桶
**map中有增量扩容和等量扩容两种**
    map扩容的条件:
            - **当负载因子(键的数量/bucket的数量)>6.5的时候:**
                代表元素太多,桶太少,翻倍扩容,要注意翻倍扩容后,值不会立刻迁入到新桶
            - **当溢出桶的数量>2^15时:**
                代表元素不是特别多,但溢出桶太多,很多桶没装满,目的是开辟新桶,将老桶中的
        元素迁移过去,紧密排列,目的是节省空间,提高查找效率

  都是采取渐进式的扩容,不会立马将所有键值对迁移到新桶  

### 19.make和new什么区别?

make 函数：
    能够创建类型所需的内存空间，返回引用类型的本身。
具有使用范围的局限性，仅支持 channel、map、slice 三种类型。
具有独特的优势，make 函数会对三种类型的内部数据结构（长度、容量等）赋值。

new 函数：
    new只用于分配内存，返回一个指向地址的指针。它为每个新类型分配一片内存，初始化为0且返回类型*T的内存地址，它相当于&T{}

### 20.pprof怎么使用？什么是火焰图?

<https://segmentfault.com/a/1190000040670962>

### 21.数组与切片的区别?

数组是定长的,是值类型,长度无法动态变化(初始化时就已经确定)
而切片是引用类型,是一个轻量级的数据结构,包含指向底层数组的指针,长度,容量,会在需要时发生扩容

### 22.beego和gin的区别?为什么gin比beego要快?

1.Beego支持完整的MVC, Gin不支持完整的MVC（需要开发者自己实现MVC）
2.Beego支持正则路由， Gin不支持正则路由
3.Beego支持Session， Gin不支持Session(需要安装另外的包)
4.gin更加轻量级,性能更强,在业务相对简单时可以使用gin,而beego则更加全面,功能齐全,但是相对来说也更加重量级
一些

### 23.defer的原理

<https://zhuanlan.zhihu.com/p/63354092>  

defer底层主要是两个函数:  
     `func deferproc(siz int32, fn *funcval)`和
     `func deferreturn(arg0 uintptr)`  

当程序执行时会先执行`deferproc`,会将defer的对象插入到**goroutine关联的defer链表头部(也是因此,defer只对当前g有效)**,之后执行defer时就是按照出栈的顺序了

注意**return实际不是原子操作**,而是分为了两步,赋值和返回,而defer恰好是在这两步之间执行的!

#### defer扩展

**defer、return、返回值三者的执行逻辑应该是：return最先执行，return负责将结果写入返回值中；接着defer开始执行一些收尾工作；最后函数携带当前返回值真正退出**。

- 匿名返回值:return会创建一个临时变量存放返回值,之后defer再对t的修改不会影响返回值(所以输出为5)
- 有名返回值(t):return将5赋值给t,之后defer是对同一个变量t修改,最终返回的是被defer修改后的t

此类题关键点在于关注返回值为具名返回值还是匿名返回值

### 24.什么是cas？Go中CAS是怎么回事？

CAS算法（Compare And Swap）,是原子操作的一种, CAS算法是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。
Go中的CAS操作是借用了CPU提供的原子性指令来实现。CAS操作修改共享变量时候不需要对共享变量加锁，而是通过类似乐观锁的方式进行检查，本质还是不断的占用CPU 资源换取加锁带来的开销（比如上下文切换开销）。  

`atomic.CompareAndSwapInt32`具有三个参数，第一个是变量的地址，第二个是变量当前值，第三个是要修改变量为多少，该函数如果发现传递的old值等于当前变量的值，则使用第三个变量替换变量的值并返回true，否则返回false。
该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。

### 25.Go值接收者和指针接收者的区别？

两个方面来对比,从是否修改调用者来对比:

如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。
使用指针作为方法的接收者的理由：
方法能够修改接收者指向的值。
避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。

从实现接口方面来对比:
如果某个接口包含一个指针接收者的方法,那么只有调用此方法者为对应指针,才能实现这个接口(即将其赋值给接口)

### 26.Goroutine发生了泄漏如何检测？

可以通过Go自带的工具pprof检测诊断当前在系统上运行的Go进程的占用的资源.

### 27.为何GPM调度要有P?

<https://segmentfault.com/a/1190000040092613>  

最开始的go中只有G和M,M想要执行,放回G都必须访问全局队列,并且多线程访问同一资源需要加锁,主要有以下缺点:
1.激烈的全局锁竞争
2.如果一个G在执行中又创建G,此刻的M必须将G交给另一个M来执行,CPU在M件频繁切换增加系统开销
为了解决这个问题,引入了P
    每个 P 有自己的本地队列，大幅度的减轻了对全局队列的直接依赖，所带来的效果就是锁竞争的减少。而 GM 模型的性能开销大头就是锁竞争。
    每个 P 相对的平衡上，在 GMP 模型中也实现了 Work Stealing 算法，如果 P 的本地队列为空，则会从全局队列或其他 P 的本地队列中窃取可运行的 G 来运行，减少空转，提高了资源利用率。

### 28.什么是闭包？什么是闭包的延迟加载?

<https://www.bilibili.com/video/BV1hv411x7we?p=7>

闭包(Closure)通俗点讲就是能够访问外部函数内部变量的函数。像这样能被访问的变量通常被称为捕获变量。  
闭包的延迟简而言之就是闭包返回的内层函数不会立即执行, 而是在使用时候才执行

### 29.如何限制goroutine的数量?控制在多少个比较合适?

<https://segmentfault.com/a/1190000039773754>  

可以设置有缓冲的channel,每个协程开启时时向channel中写入一个数据,利用有缓冲通道缓冲满时会阻塞的原理限制goroutine的数量

### 30.互斥锁有几种模式?

Go实现的互斥锁有两种模式，分别是正常模式和饥饿模式。
在正常模式下，waiter按照先进先出（FIFO）的方式获取锁，但是一个刚被唤醒的waiter与新到达的goroutine竞争锁时，大概率是干不过的。新来的goroutine有一个优势：它已经在CPU上运行，并且有可能不止一个新来的，因此waiter极有可能失败。在这种情况下，waiter还需要在等待队列中排队。为了避免waiter长时间抢不到锁，当waiter超过 1ms 没有获取到锁，它就会将当前互斥锁切换到饥饿模式，防止等待队列中的waiter被饿死。

在饥饿模式下，锁的所有权直接从解锁（unlocking）的goroutine转移到等待队列中的队头waiter。新来的goroutine不会尝试去获取锁，也不会自旋。它们将在等待队列的队尾排队。
如果某waiter获取到了锁，并且满足以下两个条件之一，它就会将锁从饥饿模式切换回正常模式。
它是等待队列的最后一个goroutine
它等待获取锁的时间小于1ms
饥饿模式是在 Go 1.9版本引入的，它防止了队列尾部waiter一直无法获取锁的问题。与饥饿模式相比，正常模式下的互斥锁性能更好。因为相较于将锁的所有权明确赋予给唤醒的waiter，直接竞争锁能降低整体goroutine获取锁的延时开销。

### 31.go中的逃逸分析是什么?

<https://zhuanlan.zhihu.com/p/343562181>  

编译器通过逃逸分析技术去选择堆或者栈，逃逸分析的基本思想如下：检查变量的生命周期是否是完全可知的，如果通过检查，则可以在栈上分配(如果变量离开作用域后没有被引用，则优先分配到栈上)。否则，就是所谓的逃逸，必须在堆上进行分配.  

发生逃逸的几种情况:  

    1. 操作类型不确定的变量(空接口)
    2. 变量被外部引用(变量在函数外部存在引用,如函数内部创建的变量返回值为该变量的指针)
    3. 变量所占内存巨大

Go语言虽然没有明确说明逃逸分析规则，但是有以下几点准则，是可以参考的:  

- 逃逸分析是在编译器完成的，这是不同于jvm的运行时逃逸分析;
- 如果变量在函数外部没有引用，则优先放到栈中；
- 如果变量在函数外部存在引用，则必定放在堆中；

### 32.sync.Pool用过吗?是怎么用的?

Pool用来保存和复用临时对象,减少内存分配,降低GC压力;
典型场景就是在web程序中,对某个结构体的序列化和反序列化,当并发度较高时,会创建非常多的临时对象,而这些对象都是分配在堆上的,对GC会造成较大压力,影响程序性能
创建对象池之后在其中添加New函数,之后调用Get方法就能从Pool中获取到实例,用完之后Put放回对象池

### 33.init的执行顺序

不要依赖init函数的执行顺序  

遵循"深度优先"的原则:  

- 如果一个包导入了其他包，则首先初始化导入的包。

- 然后初始化当前包的常量。

- 接下来初始化当前包的变量,最后，调用当前包的 init() 函数。

`import->常量->变量->init()`

### 34.接口的内部实现

接口类型由两种表示方式:`iface`和`eface`,前者表示拥有方法的列表的接口,后者表示空接口类型,2者均具有2个指针字段,并且由一个指针功能相同:**指向当前赋值给该接口的动态类型变量的值**,不同点在于eface没有方法列表,因此其另一个指针指向一个`_type`结构,该结构为该接口类型变量的动态类型的信息  
而iface除了要存动态类型的信息之外,还有存放接口本身的信息(接口的类型信息,方法列表等),因此iface第一个字段是指向`itab`类型的指针,`itab`中同样有`_type`存放动态类型信息,`inter`存放接口自身的信息(类型,包路径,接口方法集合切片),`fun`中是已实现接口方法的调用地址的数组(容量为1,第一个方法的指针)

### 35.Go的内存管理原理

<https://blog.csdn.net/u013616005/article/details/120463299>
<https://zhuanlan.zhihu.com/p/360306642>
<https://zhuanlan.zhihu.com/p/29216091>

参考`tcmalloc`实现,从3个方面看Go的内存管理设计

#### 管理模型

就是一个内存池, 只不过内部做了很多的优化. 比如自动伸缩内存池大小, 合理的切割内存块等等.

- 概念
  - `page`:内存页,一块8k大小的内存空间,Go和OS之间的内存申请和释放都是以page为单位的
  - `span`:内存块,一个或多个连续的`page`组成一个span
  - `sizeclass`: 空间规格, 每个 span 都带有一个 sizeclass , **标记着该 span 中的 page 应该如何使用**.
  - `object`: 对象, 用来存储一个变量数据内存空间, **一个 span 在初始化时,会被切割成一堆等大的object**. 假设 object 的大小是 16B, span 大小是 8K, 那么就会把span中的 page 就会被初始化 8K / 16B = 512 个 object . 所谓内存分配, 就是分配一个 object 出去.
  - `内存碎片`:系统(OS/各种runtime)在内存管理过程中, 会不可避免的出现**一块块无法被使用的内存空间**, 这就是内存管理的产物.
  - `内部碎片`:一般都是因为字节对齐; 为了字节对齐, 会导致一部分空间直接被放弃掉, 不做分配使用.
  - `外部碎片`:一般时因为内存的不断分配和释放, 导致一些释放的小内存块分散在内存各处, 无法被用以分配. 不过Go的内存管理机制不会引起大量外部碎片.

#### 逃逸分析

#### GC

### 36.什么是内存对齐?为什么要有内存对齐?

<https://geektutu.com/post/hpg-struct-alignment.html>

CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如 32 位的 CPU ，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。  
这么设计的目的，是减少 CPU 访问内存的次数，加大 CPU 访问内存的吞吐量。比如同样读取 8 个字节的数据，一次读取 4 个字节那么只需要读取 2 次。
CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数

### 37.defer的原理?

### 38.删除切片中间某个元素?

```go
func delete(arr []int, n int) []int {
    if n > len(arr)-1 || n < 0 {
         panic("out of index")
    }

    copy(arr[n:], arr[n+1:]) //利用copy

    return arr[:len(arr)-1]
}
```

### 39.使用一个字符串名称调用函数

```go
type Animal struct {
}

func (m *Animal) Eat() {
    fmt.Println("Eat")
}
func main() {
    animal := Animal{}
    value := reflect.ValueOf(&animal)
    f := value.MethodByName("Eat") //通过反射获取它对应的函数，然后通过call来调用
    f.Call([]reflect.Value{})
}

```

### string转为byte切片是否会发生内存分配?如何避免内存分配?

<https://zhuanlan.zhihu.com/p/270626496>

有两种转换方式

- 标准转换(最常用)

```go
   s1 := "hello"
    b := []byte(s1)

    // []byte to string
    s2 := string(b)
```

- 强制转换(unsafe)

```go
  func String2Bytes(s string) []byte {
    sh := (*reflect.StringHeader)(unsafe.Pointer(&s))
    bh := reflect.SliceHeader{
        Data: sh.Data,
        Len:  sh.Len,
        Cap:  sh.Len,
    }
  return*(*[]byte)(unsafe.Pointer(&bh))
}

  func Bytes2String(b []byte) string {
    return *(*string)(unsafe.Pointer(&b))
    }

```

使用unsafe.Pointer可以避免内存分配

其中**强制转换的性能明显好于标准转换**

1. 为啥强转换性能会比标准转换好？

2. 当数据较大时，标准转换方式会有一次分配内存的操作，从而导致其性能更差，而强转换方式却不受影响？

3. 既然强转换方式性能这么好，为啥go语言提供给我们使用的是标准转换方式？

### 40.两个goroutin交替打印

```go
func main() {
 c := make(chan int)
 go func() {
  for i := 1; i < 101; i++ {
   c <- 1
   //奇数
   if i%2 == 1 {
    fmt.Println("线程1打印:",i)
   }
  }
 }()
 go func() {
  for i := 1; i < 101; i++ {
   <- c
   //偶数
   if i%2 == 0 {
    fmt.Println("线程2打印:",i)
   }
  }
 }()
 time.Sleep(3 * time.Second)
}
```

交替打印数字和字母

```go
func main() {
        number, letter := make(chan bool), make(chan bool)
        wait := sync.WaitGroup{}
        go func() {
                i := 1
                for {
            <- number
                        fmt.Printf("%d%d", i, i + 1)
                        i += 2
                        letter <- true
                }
        }()
        wait.Add(1)
        go func(wait *sync.WaitGroup) {
                str := "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                i := 0
                for {
                        <- letter
                        if i >= utf8.RuneCountInString(str) {
                                wait.Done()
                                return
                        }
                        fmt.Print(str[i : i+2])
                        i += 2
                        number <- true
                }
        }(&wait)
        number <- true
        wait.Wait()
}
```
