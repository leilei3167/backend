# 数据库

- [数据库](#数据库)
  - [MySQL](#mysql)
    - [1.MySQL事务的特性,或者说基本要素?](#1mysql事务的特性或者说基本要素)
    - [2.MySQL的事务的隔离级别?](#2mysql的事务的隔离级别)
    - [3.什么是脏读,幻读,不可重复读?](#3什么是脏读幻读不可重复读)
    - [4.什么是MVCC?实现原理是什么?](#4什么是mvcc实现原理是什么)
  - [Redis](#redis)
    - [1.Redis的数据类型?以及他们的数据结构?](#1redis的数据类型以及他们的数据结构)
    - [2.Redis为什么快?](#2redis为什么快)
    - [3.什么是非阻塞,IO多路复用机制?](#3什么是非阻塞io多路复用机制)
    - [4.什么是缓存雪崩,缓存穿透,缓存击穿? 如何解决这些问题?](#4什么是缓存雪崩缓存穿透缓存击穿-如何解决这些问题)
  - [MongoDB](#mongodb)
  - [ES](#es)

## MySQL

### 1.MySQL事务的特性,或者说基本要素?

ACID:

1. 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，**事务中的操作要么全部成功，要么全部失败**。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。 回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
2. 一致性（Consistency） **事务必须使数据库从一个一致性状态变换到另外一个一致性状态**。以转账为例子，A向B转账，假设转账之前这两个用户的钱加起来总共是100，那么A向B转账之后，不管这两个账户怎么转，A用户的钱和B用户的钱加起来的总额还是100，这个就是事务的一致性;不可能说在A转账时刚扣完款,服务器宕机了,导致B账户余额未增加,A被白白扣款
3. 隔离性（Isolation） 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，**数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离**。 即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
4. 持久性（Durability） **一旦事务提交，则其所做的修改将会永远保存到数据库中**。即使系统发生崩溃，事务执行的结果也不能丢失。 可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。

上述的原子性,隔离性,持久性其实就是为了保证一致性

### 2.MySQL的事务的隔离级别?

1. 串行化 (Serializable) -- 相当于强行互斥,大幅度降低性能,基本不用 所有事务一个接着一个的执行，这样可以避免幻读 (phantom read)，对于基于锁来实现并发控制的数据库来说，串行化要求在执行范围查询的时候，需要获取范围锁，如果不是基于锁实现并发控制的数据库，则检查到有违反串行操作的事务时，需回滚该事务。
2. 可重复读 (Repeatable Read)(**MySQL默认隔离级别**) 所有被 Select 获取的数据都不能被修改，这样就可以避免一个事务前后读取数据不一致的情况。但是却没有办法控制幻读，因为这个时候其他事务不能更改所选的数据，但是可以增加数据，即前一个事务有读锁但是没有范围锁，为什么叫做可重复读等级呢？那是因为该等级解决了下面的不可重复读问题。 **注意：现在主流数据库都使用 MVCC 并发控制，使用之后RR（可重复读）隔离级别下是不会出现幻读的现象。**
3. 读已提交 (Read-Committed) 也叫提交读,该级别的事务能读取到已经提交的事务的数据,不会有脏读的问题;但被读取的数据也可以被其他事务修改，这样可能导致(**在不同时间的相同SQL查询中得到不同的结果,即不可重复读**(如一次事务中,首先执行了SQL_1,之后做了其他操作,之后再次执行SQL_1,两次SQL_1语句得到的结果不一样))。也就是说，事务读取的时候获取读锁，但是在读完之后立即释放(不需要等事务结束)，而写锁则是事务提交之后才释放，释放读锁之后，就可能被其他事务修改数据。
4. 读未提交 (Rea- Uncommitted) 最低的隔离等级，一个事务可以读取到另一个未提交事务的数据，会导致脏读(因为其他事务未提交的数据可能是会回滚的,因此是脏数据)。 总结: 四个级别逐渐降低，每个级别解决一个问题，事务级别越高，性能越差，大多数环境(Read committed 就可以用了)

### 3.什么是脏读,幻读,不可重复读?

1. 脏读:**读取到其他事务未提交的数据**,由于该数据可能会发生回滚,因此这种数据被称为脏数据,这种读取到脏数据的行为被称之为脏读
2. 幻读:**幻读的重点在于新增或者删除**,同样的条件, 第1次和第2次读出来的记录数不一样(如`SELECT*` 得到某个表的总行数a,第二次执行`SELECT*` 发现总数行b,相比于a增加了若干行数据)
3. 不可重复读:**不可重复读的重点是修改**,同样的SQL语句条件，第1次和第2次读取的值不一样(因为读已提交,第一次执行的查询语句和第二次执行中间间隔时间,其他事务是可以修改数据的)

### 4.什么是MVCC?实现原理是什么?

即`多版本并发控制`:通过记录多个修改的历史版本来替代锁,实现事务间的隔离效果,保证非阻塞读

## Redis

### 1.Redis的数据类型?以及他们的数据结构?

1. String:字符串,最基本的类型,其他几种数据结构都是在字符串基础之上构建的,常用于缓存,计数,Session,限速等
2. List:列表,由双向链表实现,可以做简单的消息队列,可用于程序数据上报的临时缓存,便于被数据收集组件批量收集,增大吞吐量
3. Hash:**指键值本身又是一个键值对结构**,可以用来存放用户信息,如购物车等(key:用户ID,Value:{商品1:XXX,商品2:xxx})
4. Set:集合,也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。**利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。**
5. Zset:有序集合,在集合基础上多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。

### 2.Redis为什么快?

- 纯内存操作

- 单线程操作，避免了频繁的上下文切换

- 合理高效的数据结构

- 采用了非阻塞I/O多路复用机制

### 3.什么是非阻塞,IO多路复用机制?

<https://blog.csdn.net/weixin_43673156/article/details/124101608>

### 4.什么是缓存雪崩,缓存穿透,缓存击穿? 如何解决这些问题?

<https://zhuanlan.zhihu.com/p/346651831>

## MongoDB

## ES
